<!DOCTYPE html>








<html>
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<link href="../../stylesheets/screen.css" media="all" rel="stylesheet" type="text/css" />
	<script src="http://modernizr.com/downloads/modernizr-2.5.3.js"></script>
	<script src="//code.jquery.com/jquery-1.11.2.min.js"></script>
	<script src="../../assets/js/keymaster.min.js"></script>

	<title>P2 Magazine | BDDon’t</title>
	<meta name="description" content="">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta property="og:url" content="http://localhost:8282/issue12/bdd-dont/" />

	<meta name="prismic-routing-pattern" content="/issue$issueNum/$slug">
    <meta name="prismic-routing-param" content="slug">
    <meta name="prismic-routing-param" content="issueNum">
</head>

<body class="wrapper">
	<!-- Google Tag Manager -->
	<noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-P97X8B"
	height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
	<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
	new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
	j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
	'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
	})(window,document,'script','dataLayer','GTM-P97X8B');</script>
	<!-- End Google Tag Manager -->

	<nav class="paginate">
		
			<a id="prev" class="prev" href="../../issue12/index/">◀</a>
		

		
			<a id="next" class="next" href="../../issue12/treat-every-story-the-same/">▶</a>
		
		<script>
		key('left', function() {
			window.open($("#prev")[0].href, '_self', false);
		});
		key('right', function(){
			window.open($("#next")[0].href, '_self', false);
        });
		</script>
	</nav>

	<div class="container">
		<section class="page">
			<nav class="issues">
				<ul class="clearfix">
					<li class="active"><a href="">Issue 12, October 2015</a></li>
					<li class="pull-right">Page 1 / 5</li>
				</ul>
			</nav>

			<article>
				<header>
					<h1>BDDon’t</h1>
					

					
						<p class="byline">
							Works and Music by
							
								
							Kevin Dishman
						</p>
					
				</header>
				<div class="article-body">
					<p>If you have been developing software in the last couple of years you have probably encountered a tool like Cucumber, JBehave, or SpecFlow at some point. Some of our biggest clients use these tools, in many cases because we introduced them. These tools are intended to assist teams in practicing Behavior Driven Development (BDD). Today I would like to urge you to choose a different path.</p><h3>What is BDD?</h3><p>BDD was pioneered by Dan North, who wanted to write software that was more focused on the behavior of the people using it. He felt that developers had been focusing too much on specific units of logic within the system. He decided the best way to do this was to create a process so that everyone connected to the development of the system shares a common language for expressing the behaviors of the users of the system.</p><p>This eventually led to tools being created that allow plain english statements to execute automated tests. These tools accomplish this by mapping lines of text to specific blocks of code via regular expression matching. When these plain english statements are run, the underlying blocks of code execute. These blocks of code can be anything, but it is commonly used to execute functional tests using technologies like Selenium or Watir.</p><h3>Objections</h3><h4>1. Regular expression mapping</h4><p>First up is regular expression mapping. It is the most obvious reason why I object to using BDD tools and one of the most problematic. As soon as steps with variables are added it is no longer easy to move cleanly between a step definition and where it is used in a test. Consider some of these example steps from a project I worked on for a large airline.</p><pre>Given I have booked a flight<br>Given I have booked a one-way flight<br>Given I have booked a flight with an unaccompanied minor<br>Given I have booked 2 flights</pre><p>These steps are fairly similar, but it is difficult to look at these steps and know which part is a variable. Some IDEs have plugin support to assist with mapping steps to definitions, but you still end up having to search for partial text or browse through long lists of steps.</p><p>Regular expressions have a reputation for having unexpected edge cases, which is usually addressed by surrounding them with unit tests. While this is technically possible, it is rarely done in practice. I would suggest that unit testing your functional tests is a warning sign that your tests have become too complicated. Even without regular expressions, Functional tests are already the most expensive tests to write, run, and curate, not to mention manage and keep green. Adding additional complexity in the form of maintaining regular expressions is a cost you can and should avoid.</p><h4>2. Step interdepencies</h4><p>The second reason for avoiding BDD tools is the issue of interdependencies between Steps. Consider the following example</p><pre>Given I have added a Darth Vader Poster to my shopping cart<br>When I complete my purchase with bitcoins<br>Then I should see my confirmation details</pre><p>In order to test what the user should see on the confirmation page, we need to save some information from the previous steps. In this case, information about the specific product purchased must be saved as well as the mechanism for payment. While saving state is a normal practice for tests, the way BDD framework accomplish this is problematic.</p><p>To save information about choices you have made within the step definitions for the Given and When. In our example above this means you need some code within the step definition that saves the fact you have chosen to buy a “Darth Vader Poster” as well as that you paid with “bitcoins”. Once we have saved this information, we need to be able to retrieve or modify it. There is no enforced order for what steps are used in a test, so now all steps created need to be able to access the information saved by any other step. This means that a feature of BDD Frameworks is that state saved in step definitions is shared globally with all other steps. At the risk of stating the obvious, global state is usually considered a bad thing.</p><blockquote><p>“It is tempting to write clever steps that sidestep problems with conditional logic and defaults, but this quickly becomes a dark rabbit hole.”</p></blockquote><p>Global state is not the only disadvantage to this approach. This approach also also introduces the complexity of steps depending on other steps. For the third step in the above example to be run, there needs to have been specific steps preceding it. If the first two steps don’t save details about the poster and the payment method, the third step will not be able to assert anything. Someone not intimately familiar with the code has no way of knowing what each step saves and what data other steps rely upon having access to. It is easy to construct what appears like a valid scenario from a user’s perspective, which will not work because of the underlying dependencies. It is tempting to write clever steps that sidestep these problems with conditional logic and defaults, but this quickly becomes a dark rabbit hole. The bottom line is by the time your code is clever enough to handle whatever can go wrong, it will be as complicated as your application itself.</p><h3>Alternative tools</h3><p>As I’ve explained, choosing to use a BDD framework introduces quite a bit of complexity. The end result is behaviors written in plain english instead of code. A BDD tool’s value proposition supposes that plain english statements is how stakeholders will communicate, and that this is easier to understand. In most cases these stakeholders need to present their vision not just to the development team, but also to external stakeholders. For that they certainly will not limit themselves to just english statements. For example, the Visual, Auditory and Kinesthetic (VAK) learning model demonstrates that if you want to present an idea or share information you will need more than just words to get many stakeholders engaged. Even if you don’t buy into this specific model using other tools like mockups, slideshows, or financial models as well as plain english will help to present the vision to many external stakeholders. Reverse engineering these multi faceted requirements into a BDD Tool is just not worth the effort or complexity overhead.</p><blockquote><p>“If the business is really interested in being part of specifying tests, this would be a great opportunity for them to pair with someone familiar and comfortable with the test suites the team has created.”</p></blockquote><p>Alternatively, mockups (like the one below), pictures, charts, photos, user research, interviews, analytics, documentation, and conversations are some of the real ways teams understand behaviors. It takes team expertise to convert all of these things into a working application, and the team should feel free to express that however they see fit.</p><h3>You still need tests</h3><p>This means don’t explicitly combine your requirements and your tests using a BDD tool. Tests should be written by the team at the appropriate level based upon their understanding of that feature and those specific requirements. These tests should follow the guiding principles of the test pyramid, which includes an emphasis on writing lower level tests when possible because of their speed, reliability, and low cost. These layers of tests will represent the living documentation of the application. It is a responsibility of the team to keep them updated and to ensure they represent the behaviors of the application. If the business is really interested in being part of specifying tests, this would be a great opportunity for them to pair with someone familiar and comfortable with the test suites the team has created.</p><p>In most situations there is still a need for some functional tests, but there is no need to use a heavy BDD tool. Use a framework traditionally used for unit tests for your functional tests e.g., JUnit, rspec. Name your tests and methods well, so that it would be possible to quickly understand the test even without a technical background. </p><p><script src="https://gist.github.com/kdishman/dff57db2e0cb3bf40a9c.js"></script></p><p>As you can see above, it is not hard to translate the statements from the previous example into method names so that even non technical stakeholders can still quickly understand what is being covered.</p>
				</div>

				<aside class="left-column clearfix">
					<div class="author">

                    
                        
                        
                        <div>
                            <a href="#">
                                <img class="author-avatar" src="https://prismic-io.s3.amazonaws.com/p2-magazine/4e698fac269b99825cd944220d13473efe1a393c_bouldering.jpg" />
                            </a>
                            <div>Kevin Dishman</div>
                            
                        </div>
                    
				</aside>
			</article>
		</section>
	</div>

	<div id="bottom-pages">
		<nav class="paginate">
			
				<a class="prev" href="../../issue12/index/">◀</a>
			

			
				<a class="next" href="../../issue12/treat-every-story-the-same/">▶</a>
			
		</nav>
	</div>
<script>window.routerInfosForFile = {"src":"/article.html","dst":"/issue12/bdd-dont/index.html","args":{"issueNum":"12","slug":"bdd-dont"}};</script>
</body>
</html>
